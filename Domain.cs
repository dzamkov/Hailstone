using System;
using System.Collections.Generic;
using System.Threading;

namespace Hailstone
{
    /// <summary>
    /// A interlinked collection of input/output pairs generated by a certain function.
    /// </summary>
    public class Domain
    {
        public Domain(Func<uint, uint> Generator)
        {
            this.Generator = Generator;
            this._Entries = new Dictionary<uint, Entry>();
            this._Divergent = new Dictionary<uint, List<Entry>>();
        }

        /// <summary>
        /// The generator function for this domain.
        /// </summary>
        public readonly Func<uint, uint> Generator;

        /// <summary>
        /// Gets the amount of entries in this domain.
        /// </summary>
        public int Size
        {
            get
            {
                return this._Entries.Count;
            }
        }

        /// <summary>
        /// Gets the domain entry for the given value. If it does not exist, it will be created.
        /// </summary>
        public Entry this[uint Value]
        {
            get
            {
                Entry entry;
                if (this._Entries.TryGetValue(Value, out entry))
                    return entry;
                else
                    return this._Create(Value, this.Generator(Value));
            }
        }

        /// <summary>
        /// Gets the domain entry for the given value. Returns false if it does not exist.
        /// </summary>
        public bool TryGetEntry(uint Value, out Entry Entry)
        {
            return this._Entries.TryGetValue(Value, out Entry);
        }

        /// <summary>
        /// Fills this domain with entries for the given values.
        /// </summary>
        public void Fill(IEnumerable<uint> Values)
        {
            foreach (uint value in Values)
            {
                if (!this._Entries.ContainsKey(value))
                {
                    uint next = this.Generator(value);
                    this._Create(value, next);
                }
            }
        }

        /// <summary>
        /// Creates an entry for the given value. The entry must not already exist and there should be a lock on this._Entries.
        /// </summary>
        private Entry _Create(uint Value, uint Next)
        {
            Entry entry = new Entry(Value);
            Entry next;
            List<Entry> divergent;
            if (this._Entries.TryGetValue(Next, out next))
            {
                entry.Next = next;
                next.Previous.Add(entry);
            }
            else
            {
                if (!this._Divergent.TryGetValue(Next, out divergent))
                    this._Divergent[Next] = divergent = new List<Entry>();
                divergent.Add(entry);
            }
            if (this._Divergent.TryGetValue(Value, out divergent))
            {
                entry.Previous = divergent;
                this._Divergent.Remove(Value);
                foreach (Entry p in divergent)
                {
                    p.Next = entry;
                }
            }
            else
            {
                entry.Previous = new List<Entry>();
            }
            this._Entries[Value] = entry;
            this._CalculateWeight(entry);
            return entry;
        }

        /// <summary>
        /// Calculates the weight of an entry, and updates all dependent entries.
        /// </summary>
        private void _CalculateWeight(Entry Entry)
        {
            uint weight = 1;
            foreach (Entry prev in Entry.Previous)
                weight += prev.Weight;
            Entry.Weight = weight;

            Entry cur = Entry.Next;
            while (true)
            {
                if (cur == null) return;
                if (cur.Weight == uint.MaxValue) return;
                if (cur == Entry)
                {
                    Entry.Weight = uint.MaxValue;
                    cur = Entry.Next;
                    while (cur != Entry)
                    {
                        cur.Weight = uint.MaxValue;
                        cur = cur.Next;
                    }
                }
                cur.Weight += weight;
                cur = cur.Next;
            }
        }

        private Dictionary<uint, Entry> _Entries;
        private Dictionary<uint, List<Entry>> _Divergent;
    }

    /// <summary>
    /// An entry for a value in a domain.
    /// </summary>
    public class Entry
    {
        public Entry(uint Value)
        {
            this.Value = Value;
        }

        /// <summary>
        /// The value of this entry.
        /// </summary>
        public readonly uint Value;

        /// <summary>
        /// The entries in the associated domain which produce the value of this entry when applied to the generator function.
        /// </summary>
        public List<Entry> Previous;

        /// <summary>
        /// The entry in the associated domain produced by the generator function when this entry is used as the input.
        /// </summary>
        public Entry Next;

        /// <summary>
        /// One plus the sum of the weights of the previous entries. If this entry is part of a loop, its weight will be uint.MaxValue.
        /// </summary>
        public uint Weight;
    }
}