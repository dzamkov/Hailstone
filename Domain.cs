using System;
using System.Collections.Generic;
using System.Threading;

namespace Hailstone
{
    /// <summary>
    /// A interlinked collection of input/output pairs generated by a certain function.
    /// </summary>
    public class Domain
    {
        public Domain(Func<uint, uint> Generator)
        {
            this.Generator = Generator;
            this._Entries = new Dictionary<uint, Entry>();
            this._Divergent = new Dictionary<uint, List<Entry>>();
        }

        /// <summary>
        /// The generator function for this domain.
        /// </summary>
        public readonly Func<uint, uint> Generator;

        /// <summary>
        /// Gets the amount of entries in this domain.
        /// </summary>
        public int Size
        {
            get
            {
                return this._Entries.Count;
            }
        }

        /// <summary>
        /// Gets the domain entry for the given value. If it does not exist, it will be created.
        /// </summary>
        public Entry this[uint Value]
        {
            get
            {
                Entry entry;
                if (this._Entries.TryGetValue(Value + 1, out entry))
                    return entry;
                else
                    return this._Create(Value, this.Generator(Value));
            }
        }

        /// <summary>
        /// Gets the domain entry for the given value. Returns false if it does not exist.
        /// </summary>
        public bool TryGetEntry(uint Value, out Entry Entry)
        {
            return this._Entries.TryGetValue(Value, out Entry);
        }

        /// <summary>
        /// Fills this domain with entries for the given values.
        /// </summary>
        public void Fill(IEnumerable<uint> Values)
        {
            foreach (uint value in Values)
            {
                if (!this._Entries.ContainsKey(value))
                {
                    uint next = this.Generator(value);
                    this._Create(value, next);
                }
            }
        }

        /// <summary>
        /// Creates an entry for the given value. The entry must not already exist and there should be a lock on this._Entries.
        /// </summary>
        private Entry _Create(uint Value, uint Next)
        {
            Entry entry = new Entry(Value);
            Entry next;
            if (this._Entries.TryGetValue(Next, out next))
            {
                entry.Next = next;
                next.Previous.Add(entry);
            }
            else
            {
                List<Entry> divergent;
                if (!this._Divergent.TryGetValue(Next, out divergent))
                    this._Divergent[Next] = divergent = new List<Entry>();
                divergent.Add(entry);
            }
            if (this._Divergent.TryGetValue(Value, out entry.Previous))
                this._Divergent.Remove(Value);
            else
                entry.Previous = new List<Entry>();
            this._Entries[Value] = entry;
            return entry;
        }

        private Dictionary<uint, Entry> _Entries;
        private Dictionary<uint, List<Entry>> _Divergent;
    }

    /// <summary>
    /// An entry for a value in a domain.
    /// </summary>
    public class Entry
    {
        public Entry(uint Value)
        {
            this.Value = Value;
        }

        /// <summary>
        /// The value of this entry.
        /// </summary>
        public readonly uint Value;

        /// <summary>
        /// The entries in the associated domain which produce the value of this entry when applied to the generator function.
        /// </summary>
        public List<Entry> Previous;

        /// <summary>
        /// The entry in the associated domain produced by the generator function when this entry is used as the input.
        /// </summary>
        public Entry Next;
    }
}